# api/worker.py

import asyncio
import os
import re
from pathlib import Path
from typing import Dict, Any

from celery import Celery
from celery.utils.log import get_task_logger

# Import the core pipeline function and context object
from catalyst.main import run_pipeline
from catalyst.context import RunContext

# --- Configuration ---
# The logger for Celery tasks
logger = get_task_logger(__name__)

# Load the Redis URL from environment variables, with a default for local dev
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")

# --- START OF MODIFICATION ---
# Load the public-facing base URL for assets from environment variables.
# This is crucial for constructing correct, client-usable image URLs.
# Example: "http://localhost:9500" or "https://api.yourcompany.com"
ASSET_BASE_URL = os.getenv("ASSET_BASE_URL", "http://127.0.0.1:9500")
# --- END OF MODIFICATION ---

# Initialize the Celery application
celery_app = Celery(
    "creative_catalyst_worker",
    broker=REDIS_URL,
    backend=REDIS_URL,
    include=["api.worker"],
)

# --- START OF NEW HELPER FUNCTIONS ---


def _create_slug(text: str) -> str:
    """
    Creates a URL-friendly slug from a string.

    This function is the single source of truth for converting a key piece name
    into a filename-safe slug. It must be used by both this module and the
    image generator modules to ensure filenames can be matched correctly.

    Args:
        text: The input string (e.g., a key piece name).

    Returns:
        A cleaned, lowercased, hyphenated slug.
    """
    if not text:
        return "untitled"
    # Handle common special characters before general substitution
    text = text.replace("'", "").replace("&", "and")
    # Keep only alphanumeric characters, spaces, and hyphens
    text = re.sub(r"[^a-zA-Z0-9\s-]", "", text.lower())
    # Replace spaces and multiple hyphens with a single hyphen
    slug = re.sub(r"[\s-]+", "-", text).strip("-")
    return slug


def _inject_image_urls_into_report(
    final_report: Dict[str, Any], results_dir: Path, base_url: str
) -> Dict[str, Any]:
    """
    Scans the results directory for generated images and injects their
    public URLs directly into the corresponding 'detailed_key_pieces' entries.

    Args:
        final_report: The final report dictionary generated by the pipeline.
        results_dir: The path to the final, timestamped results folder.
        base_url: The public base URL for serving assets.

    Returns:
        The modified final_report dictionary with image URLs embedded.
    """
    logger.info("Injecting public image URLs into the final report...")
    try:
        # The public path segment for the results (e.g., "results/20250903-...")
        public_path = f"results/{results_dir.name}"

        # 1. Create a mapping of filename slugs to their full public URLs
        url_map = {}
        if results_dir.exists():
            for file_path in results_dir.glob("*.png"):
                # Key: "the-sculpted-power-jacket", Value: "http://.../the-sculpted-power-jacket.png"
                url_map[file_path.stem] = (
                    f"{base_url.rstrip('/')}/{public_path}/{file_path.name}"
                )

        if not url_map:
            logger.warning(
                "No .png images found in results directory. URLs will not be injected."
            )
            return final_report

        # 2. Iterate through key pieces and inject the URLs
        if (
            "detailed_key_pieces" in final_report
            and final_report["detailed_key_pieces"]
        ):
            for piece in final_report["detailed_key_pieces"]:
                piece_name = piece.get("key_piece_name")
                if not piece_name:
                    continue

                # Generate the expected slugs for this piece
                piece_slug = _create_slug(piece_name)
                garment_slug = piece_slug
                moodboard_slug = f"{piece_slug}-moodboard"

                # Find and assign the URLs from the map, defaulting to None if not found
                piece["final_garment_image_url"] = url_map.get(garment_slug)
                piece["mood_board_image_url"] = url_map.get(moodboard_slug)

        logger.info("✅ Successfully injected image URLs.")
        return final_report

    except Exception as e:
        logger.error(f"❌ Failed to inject image URLs into report: {e}", exc_info=True)
        # Return the original report on failure to avoid breaking the entire response
        return final_report


# --- END OF NEW HELPER FUNCTIONS ---


@celery_app.task(name="create_creative_report")
def create_creative_report(user_passage: str) -> Dict[str, Any]:
    """
    The main Celery task that executes the full creative pipeline and
    formats the final, client-friendly response.
    """
    logger.info(f"Received creative brief for processing: '{user_passage[:100]}...'")
    try:
        # Run the entire pipeline and get the final context
        context: RunContext = asyncio.run(run_pipeline(user_passage))

        final_report = context.final_report
        if not final_report:
            raise RuntimeError("Pipeline finished but produced an empty final report.")

        # --- START OF MODIFICATION ---
        # Instead of returning a separate list of URLs, inject them directly
        # into the final_report object for a cleaner, more integrated response.
        modified_report = _inject_image_urls_into_report(
            final_report=final_report,
            results_dir=context.results_dir,
            base_url=ASSET_BASE_URL,
        )

        # The final result of the job is a dictionary containing the
        # modified report and the path to the artifacts on the server.
        # The top-level 'image_urls' key is now removed from the response structure.
        return {
            "final_report": modified_report,
            "artifacts_path": str(context.results_dir),
        }
        # --- END OF MODIFICATION ---

    except Exception as e:
        logger.critical(
            f"❌ A critical error occurred during the pipeline execution: {e}",
            exc_info=True,
        )
        # Propagate the exception to mark the Celery task as FAILED
        raise
