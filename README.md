# ðŸš€ Creative Catalyst Engine

[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](https://github.com/your-username/creative-catalyst-engine)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

The **Creative Catalyst Engine** is an AI-powered idea-to-image pipeline delivered as a scalable web service. It transforms a simple creative brief into a multi-format fashion intelligence package: a structured trend report (JSON), art-directed narrative prompts, and a suite of editorial-quality imagesâ€”including final garments and atmospheric mood boardsâ€”generated by modern generative models.

Built on FastAPI, Celery, and Redis, the engine is designed for resilience, scalability, and easy integration into creative workflows. It now features an advanced two-level caching system that guarantees performance and 100% consistency for repeated or similar requests.

---

## Table of Contents

- [ðŸš€ Creative Catalyst Engine](#-creative-catalyst-engine)
  - [Table of Contents](#table-of-contents)
  - [Key Features](#key-features)
  - [Architecture Overview](#architecture-overview)
    - [Environment Variables](#environment-variables)
  - [Running the Engine](#running-the-engine)
    - [1) Start Redis (Docker)](#1-start-redis-docker)
    - [2) Start Celery Worker](#2-start-celery-worker)
    - [3) Start the API Server](#3-start-the-api-server)
  - [Interacting with the Engine](#interacting-with-the-engine)
    - [Recommended: Use the API client](#recommended-use-the-api-client)
    - [Direct API (curl)](#direct-api-curl)
    - [Local testing (debugging pipeline)](#local-testing-debugging-pipeline)
  - [Outputs](#outputs)
  - [Troubleshooting](#troubleshooting)
  - [Notes on Rendering](#notes-on-rendering)

---

## Key Features

*   **Asynchronous & Scalable**: FastAPI front end accepts jobs immediately and queues them to Celery + Redis for background processing.
*   **Two-Level L0/L1 Caching**: Employs a high-speed, hash-based L0 cache for exact-match queries and a fallback L1 semantic vector search for similar briefs, ensuring optimal performance.
*   **Full Artifact Caching**: Caches the complete output package, including the JSON report and all generated images (mood boards and final garments), guaranteeing 100% consistency on cache hits.
*   **Demographic-Aware Image Generation**: Intelligently infers gender, age, and ethnicity from the creative brief to generate highly relevant and context-aware model imagery.
*   **AI Creative Direction**: Intermediate AI step converts brand ethos into a professional photography style guide for art-directed image prompts.
*   **Mood Board Generation**: Automatically creates atmospheric mood board images alongside final garment shots for a richer creative intelligence package.
*   **Pluggable Image Generation Models**: Easily switch between different image generation models (DALL-E 3, Gemini NanoBanana, etc.) via a simple configuration change.
*   **Robust & Decoupled Cache Storage**: Caches artifacts in a permanent, dedicated storage directory, preventing accidental deletion from routine cleanup of user-facing results.

---

## Architecture Overview

The engine is architected as a modern, decoupled web service. The diagram below illustrates the flow of a request, including the new, robust caching layer that short-circuits the pipeline for known requests.

<br>

<details>
<summary>Click to view the Mermaid diagram source code</summary>

```mermaid
graph LR
    subgraph Client
        A[Company Program via api_client]
    end

    subgraph API Server
        B(FastAPI)
    end

    subgraph Message Broker & Result Backend
        C[(Redis)]
    end

    subgraph Background Worker
        D{Celery Worker}
    end

    subgraph Caching Service
        G[(ChromaDB <br> L0/L1 Cache)]
    end

    subgraph External Services
        E[Image Generation APIs <br> DALL-E 3, Gemini]
        F[Google Gemini API]
    end

    A -- 1. POST /v1/creative-jobs --> B
    B -- 2. Enqueue Job --> C
    B -- 3. Return Job ID to Client --> A
    C -- 4. Dequeue Job --> D
    D -- 5. Briefing Stage --> D
    D -- 6. Check Cache --> G
    G -- 7a. Cache Hit --> D
    D -- 8a. Restore Artifacts --> D
    G -- 7b. Cache Miss --> D
    D -- 8b. Run Synthesis Pipeline --> D
    D -- 9a. Call for Synthesis --> F
    D -- 9b. Call for Image Generation --> E
    D -- 10. Store Result in Redis --> C
    D -- 11. Add New Artifacts to Cache --> G
    A -- 12. Poll GET /v1/jobs/{id} --> B
    B -- 13. Fetch Result from Redis --> C
    C -- 14. Return Final Report --> B
    B -- 15. Send Final Report to Client --> A
```</details>

---

## Repository Structure

```
creative-catalyst-engine/
â”œâ”€â”€ .env
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”‚
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ worker.py
â”‚   â””â”€â”€ eventlet_worker.py
â”‚
â”œâ”€â”€ api_client/
â”‚   â”œâ”€â”€ client.py
â”‚   â”œâ”€â”€ exceptions.py
â”‚   â””â”€â”€ example.py
â”‚
â”œâ”€â”€ artifact_cache/   <-- Permanent storage for cached reports & images
â”‚
â”œâ”€â”€ catalyst/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ settings.py
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ results/          <-- Rotating storage for the latest N user-facing runs
```

---

## Setup and Configuration

### Prerequisites

*   **Python 3.11+**
*   **Docker Desktop** (for Redis). Install: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)

### Installation

```bash
git clone https://github.com/your-username/creative-catalyst-engine.git
cd creative-catalyst-engine

python3 -m venv venv
source venv/bin/activate

pip install -r requirements.txt
```

### Environment Variables

Create a `.env` file in the project root (ignored by Git).

```ini
# .env

# Required API keys
GEMINI_API_KEY="your_gemini_api_key_here"
OPENAI_API_KEY="your_openai_api_key_here"

# Feature flags & Model Selection
ENABLE_IMAGE_GENERATION=True
IMAGE_GENERATION_MODEL="dall-e-3"  # Options: "dall-e-3", "gpt-image-1", "nano-banana"

# Infrastructure
REDIS_URL="redis://localhost:6379/0"
```

---

## Running the Engine

You will typically run three processes in separate terminals (API, Celery worker, and Redis container).

### 1) Start Redis (Docker)

```bash
docker run -d -p 6379:6379 --name creative-catalyst-redis redis
# or, if already created:
docker start creative-catalyst-redis
```

### 2) Start Celery Worker

Terminal 1 (Linux / WSL):
```bash
source venv/bin/activate
celery -A api.worker.celery_app worker --loglevel=info
```

macOS (use eventlet to avoid certain macOS networking issues):
```bash
source venv/bin/activate
celery -A api.eventlet_worker.celery_app worker --loglevel=info -P eventlet
```

### 3) Start the API Server

Terminal 2:
```bash
source venv/bin/activate
uvicorn api.main:app --reload --port 9500 --host 0.0.0.0
```

---

## Interacting with the Engine

### Recommended: Use the API client

Run the example client to submit a job, poll for results, and download the generated images:

```bash
python -m api_client.example
```

### Direct API (curl)

Submit a job:
```bash
curl -X POST "http://127.0.0.1:9500/v1/creative-jobs" \
  -H "Content-Type: application/json" \
  -d '{"user_passage": "A report on the New Look silhouette, modernized for today\'s Dior."}'
```
That returns a `job_id` you can poll with `GET /v1/creative-jobs/{job_id}`.

### Local testing (debugging pipeline)

Edit `catalyst/main.py` and change `USER_PASSAGE`, then:
```bash
python -m catalyst.main
```

---

## Outputs

On success, outputs are stored under `./results/` in a timestamped folder. The API response will contain:
*   `final_report`: The full, structured JSON trend report.
*   `image_urls`: A list of public URLs to the generated images. This now includes both final garment shots (e.g., `the-sculpted-parka.png`) and mood board images (e.g., `the-sculpted-parka-moodboard.png`).

---

## Troubleshooting

*   **502 Bad Gateway / Could not connect:** This is a network issue.
    1.  Ensure the API server is running (`uvicorn ...`).
    2.  If connecting from another machine, ensure you started the server with `--host 0.0.0.0` and are using the correct network IP address, not `127.0.0.1`.
    3.  Check for firewalls blocking port `9500`.
*   **API response has an empty `image_urls` list:** Check the Celery worker logs. This means the image generation step was either disabled (`ENABLE_IMAGE_GENERATION=False`) or failed. The worker log will contain the specific error traceback.
*   **500 Internal Server Error:** Check the Celery worker logs. This indicates an error during the background job execution.

---

## Notes on Rendering

*   **Project title visibility**: If your README begins with large badges or HTML comments before the first H1, some viewers or site integrations may display the repository name instead of the README H1. To be safe, place the `# Title` at the very top (as done above).
*   **Mermaid diagrams**: Use `\n` for multi-line node labels (avoid raw HTML like `<br>`). If the diagram still doesnâ€™t render in your environment, try using an online editor or a VS Code extension with Mermaid support.